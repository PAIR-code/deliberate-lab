/**
 * API endpoints for cohort management (Express version)
 */

import {Timestamp} from 'firebase-admin/firestore';
import {Response} from 'express';
import createHttpError from 'http-errors';
import {
  DeliberateLabAPIRequest,
  hasDeliberateLabAPIPermission,
  verifyExperimentAccess,
  verifyExperimentOwnership,
} from './dl_api.utils';
import {
  validateCohortParticipantConfig,
  validateSchema,
} from '../utils/validation';
import {
  CohortConfig,
  CohortParticipantConfig,
  MetadataConfig,
  MetadataConfigSchema,
  ParticipantStatus,
  UnifiedTimestamp,
  createCohortConfig,
  createMetadataConfig,
  createCohortParticipantConfig,
} from '@deliberation-lab/utils';
import {app} from '../app';
import {createCohortInternal} from '../cohort.utils';
import {getFirestoreCohortRef} from '../utils/firestore';

// ************************************************************************* //
// TYPES                                                                     //
// ************************************************************************* //

interface CreateCohortRequest {
  name: string;
  description?: string;
  participantConfig?: Partial<CohortParticipantConfig>;
}

interface UpdateCohortRequest {
  name?: string;
  description?: string;
  participantConfig?: Partial<CohortParticipantConfig>;
}

// ************************************************************************* //
// ENDPOINTS                                                                 //
// ************************************************************************* //

/**
 * List cohorts for an experiment
 */
export async function listCohorts(
  req: DeliberateLabAPIRequest,
  res: Response,
): Promise<void> {
  if (!hasDeliberateLabAPIPermission(req, 'read')) {
    throw createHttpError(403, 'Insufficient permissions');
  }

  const experimentId = req.params.experimentId;
  const experimenterId = req.deliberateLabAPIKeyData!.experimenterId;

  if (!experimentId) {
    throw createHttpError(400, 'Experiment ID required');
  }

  // Verify access to experiment
  await verifyExperimentAccess(experimentId, experimenterId);

  const snapshot = await app
    .firestore()
    .collection('experiments')
    .doc(experimentId)
    .collection('cohorts')
    .get();

  const cohorts = snapshot.docs.map((doc) => ({
    id: doc.id,
    ...doc.data(),
  }));

  res.status(200).json({
    cohorts,
    total: cohorts.length,
  });
}

/**
 * Create a new cohort
 */
export async function createCohort(
  req: DeliberateLabAPIRequest,
  res: Response,
): Promise<void> {
  if (!hasDeliberateLabAPIPermission(req, 'write')) {
    throw createHttpError(403, 'Insufficient permissions');
  }

  const experimentId = req.params.experimentId;
  const experimenterId = req.deliberateLabAPIKeyData!.experimenterId;

  if (!experimentId) {
    throw createHttpError(400, 'Experiment ID required');
  }

  // Verify ownership (only creator can add cohorts)
  await verifyExperimentOwnership(experimentId, experimenterId);

  const body = req.body as CreateCohortRequest;
  const timestamp = Timestamp.now() as UnifiedTimestamp;

  // Create metadata config
  const metadata: MetadataConfig = {
    ...createMetadataConfig(),
    name: body.name,
    description: body.description || '',
    creator: experimenterId,
    dateCreated: timestamp,
    dateModified: timestamp,
  };

  // Validate metadata
  const metadataValidation = validateSchema(MetadataConfigSchema, metadata);
  if (!metadataValidation.valid) {
    throw createHttpError(400, metadataValidation.error);
  }

  // Create participant config with any provided overrides
  const participantConfig: CohortParticipantConfig = {
    ...createCohortParticipantConfig(),
    ...body.participantConfig,
  };

  // Validate merged participantConfig (schema + business logic)
  const participantValidation =
    validateCohortParticipantConfig(participantConfig);
  if (!participantValidation.valid) {
    throw createHttpError(400, participantValidation.error);
  }

  // Create cohort config (variableMap is generated by createCohortInternal based on experiment's variableConfigs)
  const cohortConfig = createCohortConfig({
    metadata,
    participantConfig,
  });

  // Use transaction for consistency (createCohortInternal handles all the complex initialization)
  await app.firestore().runTransaction(async (transaction) => {
    // Check if cohort already exists
    const cohortRef = getFirestoreCohortRef(experimentId, cohortConfig.id);
    const existingDoc = await transaction.get(cohortRef);
    if (existingDoc.exists) {
      throw createHttpError(409, 'Cohort with this ID already exists');
    }

    // Create cohort with all related data (public stage data, mediators, etc.)
    await createCohortInternal(transaction, experimentId, cohortConfig);
  });

  res.status(201).json({
    cohort: cohortConfig,
  });
}

/**
 * Get a specific cohort
 */
export async function getCohort(
  req: DeliberateLabAPIRequest,
  res: Response,
): Promise<void> {
  if (!hasDeliberateLabAPIPermission(req, 'read')) {
    throw createHttpError(403, 'Insufficient permissions');
  }

  const experimentId = req.params.experimentId;
  const cohortId = req.params.cohortId;
  const experimenterId = req.deliberateLabAPIKeyData!.experimenterId;

  if (!experimentId) {
    throw createHttpError(400, 'Experiment ID required');
  }
  if (!cohortId) {
    throw createHttpError(400, 'Cohort ID required');
  }

  // Verify access to experiment
  await verifyExperimentAccess(experimentId, experimenterId);

  const cohortRef = getFirestoreCohortRef(experimentId, cohortId);
  const cohortDoc = await cohortRef.get();

  if (!cohortDoc.exists) {
    throw createHttpError(404, 'Cohort not found');
  }

  const cohortConfig = cohortDoc.data() as CohortConfig;

  // Optionally include participant count
  const participantsSnapshot = await app
    .firestore()
    .collection('experiments')
    .doc(experimentId)
    .collection('participants')
    .where('currentCohortId', '==', cohortId)
    .count()
    .get();

  res.status(200).json({
    cohort: {...cohortConfig, id: cohortId},
    participantCount: participantsSnapshot.data().count,
  });
}

/**
 * Update a cohort
 */
export async function updateCohort(
  req: DeliberateLabAPIRequest,
  res: Response,
): Promise<void> {
  if (!hasDeliberateLabAPIPermission(req, 'write')) {
    throw createHttpError(403, 'Insufficient permissions');
  }

  const experimentId = req.params.experimentId;
  const cohortId = req.params.cohortId;
  const experimenterId = req.deliberateLabAPIKeyData!.experimenterId;

  if (!experimentId) {
    throw createHttpError(400, 'Experiment ID required');
  }
  if (!cohortId) {
    throw createHttpError(400, 'Cohort ID required');
  }

  // Verify ownership (only creator can update cohorts)
  await verifyExperimentOwnership(experimentId, experimenterId);

  const body = req.body as UpdateCohortRequest;

  await app.firestore().runTransaction(async (transaction) => {
    const cohortRef = getFirestoreCohortRef(experimentId, cohortId);
    const cohortDoc = await transaction.get(cohortRef);

    if (!cohortDoc.exists) {
      throw createHttpError(404, 'Cohort not found');
    }

    const cohortConfig = cohortDoc.data() as CohortConfig;

    // Build update object
    const updatedMetadata: MetadataConfig = {
      ...cohortConfig.metadata,
      dateModified: Timestamp.now() as UnifiedTimestamp,
    };

    if (body.name !== undefined) {
      updatedMetadata.name = body.name;
    }
    if (body.description !== undefined) {
      updatedMetadata.description = body.description;
    }

    // Validate updated metadata
    const metadataValidation = validateSchema(
      MetadataConfigSchema,
      updatedMetadata,
    );
    if (!metadataValidation.valid) {
      throw createHttpError(400, metadataValidation.error);
    }

    const updatedParticipantConfig: CohortParticipantConfig = {
      ...cohortConfig.participantConfig,
      ...body.participantConfig,
    };

    // Validate merged participantConfig (schema + business logic)
    const participantValidation = validateCohortParticipantConfig(
      updatedParticipantConfig,
    );
    if (!participantValidation.valid) {
      throw createHttpError(400, participantValidation.error);
    }

    transaction.update(cohortRef, {
      metadata: updatedMetadata,
      participantConfig: updatedParticipantConfig,
    });
  });

  res.status(200).json({
    updated: true,
    id: cohortId,
  });
}

/**
 * Delete a cohort
 */
export async function deleteCohort(
  req: DeliberateLabAPIRequest,
  res: Response,
): Promise<void> {
  if (!hasDeliberateLabAPIPermission(req, 'write')) {
    throw createHttpError(403, 'Insufficient permissions');
  }

  const experimentId = req.params.experimentId;
  const cohortId = req.params.cohortId;
  const experimenterId = req.deliberateLabAPIKeyData!.experimenterId;

  if (!experimentId) {
    throw createHttpError(400, 'Experiment ID required');
  }
  if (!cohortId) {
    throw createHttpError(400, 'Cohort ID required');
  }

  // Verify ownership (only creator can delete cohorts)
  await verifyExperimentOwnership(experimentId, experimenterId);

  // Check cohort exists
  const cohortRef = getFirestoreCohortRef(experimentId, cohortId);
  const cohortDoc = await cohortRef.get();

  if (!cohortDoc.exists) {
    throw createHttpError(404, 'Cohort not found');
  }

  // Set all participants in cohort to deleted status
  const participantsSnapshot = await app
    .firestore()
    .collection('experiments')
    .doc(experimentId)
    .collection('participants')
    .where('currentCohortId', '==', cohortId)
    .get();

  // Update participants in batches
  const batch = app.firestore().batch();
  for (const doc of participantsSnapshot.docs) {
    batch.update(doc.ref, {currentStatus: ParticipantStatus.DELETED});
  }

  // Also check for participants with transferCohortId
  const transferParticipantsSnapshot = await app
    .firestore()
    .collection('experiments')
    .doc(experimentId)
    .collection('participants')
    .where('transferCohortId', '==', cohortId)
    .get();

  for (const doc of transferParticipantsSnapshot.docs) {
    batch.update(doc.ref, {
      currentStatus: ParticipantStatus.DELETED,
      transferCohortId: null,
    });
  }

  await batch.commit();

  // Recursively delete cohort document and subcollections
  await app.firestore().recursiveDelete(cohortRef);

  res.status(200).json({
    id: cohortId,
    deleted: true,
  });
}
